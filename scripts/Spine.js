// Generated by CoffeeScript 1.8.0
var addTextNode, animate, c, canvas, go, going, head, i, setText, sim, spine, step, _i, _j, _k, _ref, _ref1;

addTextNode = function(text) {
  var newtext, p1;
  newtext = document.createTextNode(text);
  p1 = document.getElementById("p1");
  return p1.appendChild(newtext);
};

setText = function(element, text) {
  if ("textContent" in Element.prototype) {
    return element.textContent = text;
  } else {
    return element.innerText = text;
  }
};

Element.prototype.setText = function(text) {
  return setText(this, text);
};

step = document.createElement("button");

step.setText("Step");

document.body.appendChild(step);

go = document.createElement("button");

go.setText("Go");

document.body.appendChild(go);

going = true;

canvas = document.createElement("canvas");

document.body.appendChild(canvas);

c = canvas.getContext("2d");

canvas.width = window.innerWidth;

canvas.height = window.innerHeight;

c.circle = function(x, y, r) {
  c.beginPath();
  return c.arc(x, y, r, 0, Math.PI * 2, false);
};

c.clear = function() {
  return c.clearRect(0, 0, canvas.width, canvas.height);
};


/*
class Vertebra
	constructor: (x, y, n)->
		@position = {x:x, y:y}
		@velocity = {x:0, y:0}
		@force = {x:0, y:0}
		@n = n
		@weight = 1

	updatePosition: ->

		@position.x += @velocity.x
		@position.y += @velocity.y
		@velocity.x += @force.x
		@velocity.y += @force.y
		@force.x = 0
 */


/*
var Constraint = function(above, below, distance){
	@above = above
	@below = below
	@d = distance
}

Constraint.prototype.applyForce = function() {
 
	var dx = @below.position.x - @above.position.x
	var dy = @below.position.y - @above.position.y
	var d = Math.sqrt(dx*dx+dy*dy)
	dx *= (@d/d)
	dy *= (@d/d)
	var angle = Math.atan2(dy, dx)
	@below.force.x += @above.force.y * Math.sin(angle) + @above.force.x * Math.cos(angle)
	@below.force.y += @above.force.y * Math.cos(angle) + @above.force.x * Math.sin(angle) + @below.weight * gravity
//console.log("n=" + @below.n + " force.x="+@below.force.x + "force.y="+@below.force.y)
}
Constraint.prototype.applyConstraint = function() {
 
	var dx = @below.position.x - @above.position.x
	var dy = @below.position.y - @above.position.y
	var d = Math.sqrt(dx*dx+dy*dy)
	dx *= (@d/d)
	dy *= (@d/d)
//console.log("n="+@above.n + " dx="+dx + " dy="+dy)
	@above.position.x = @below.position.x - dx
	@above.position.y = @below.position.y - dy
	
}

var FixedPosition = function(v, x, y){
	@above = v
	@below = v
	@x = x
	@y = y
}

FixedPosition.prototype.applyForce = function() {
}
FixedPosition.prototype.applyConstraint = function() {
	@above.position.x = @x
	@above.position.y = @y
	
}
 */

Particle.prototype.draw = function() {
  c.circle(this.pos.x, this.pos.y, 5);
  return c.fill();
};

spine = new VerletJS.Composite;

head = new Particle(new Vec2(100, 25));

head.draw = function() {
  c.circle(this.pos.x, this.pos.y, 20);
  c.fill();
  c.beginPath();
  c.strokeStyle = "white";
  if (this.happy) {
    c.arc(this.pos.x, this.pos.y, 15, 0, Math.PI);
  } else {
    c.arc(this.pos.x, this.pos.y + 50, 40, Math.PI * 1.46, Math.PI * 1.54);
  }
  c.lineWidth = 3;
  c.stroke();
  c.beginPath();
  c.arc(this.pos.x - 5, this.pos.y, 4, 0, Math.PI * 2);
  c.stroke();
  c.beginPath();
  c.arc(this.pos.x + 5, this.pos.y, 4, 0, Math.PI * 2);
  c.stroke();
  return c.fillStyle = "green";
};

head.weight = 20;

spine.particles.push(head);

for (i = _i = 0; _i < 24; i = ++_i) {
  spine.particles.push(new Particle(new Vec2(100, i * 10 + 45)));
}

for (i = _j = 0, _ref = spine.particles.length - 1; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
  spine.constraints.push(new DistanceConstraint(spine.particles[i], spine.particles[i + 1], 5, spine.particles[i + 1].pos.y - spine.particles[i].pos.y));
}

for (i = _k = 1, _ref1 = spine.particles.length - 1; 1 <= _ref1 ? _k < _ref1 : _k > _ref1; i = 1 <= _ref1 ? ++_k : --_k) {
  spine.constraints.push(new AngleConstraint(spine.particles[i - 1], spine.particles[i], spine.particles[i + 1], 2.5));
}

spine.constraints.push(new PinConstraint(spine.particles[spine.particles.length - 1], spine.particles[spine.particles.length - 1].pos));

spine.constraints.push(new PinConstraint(spine.particles[spine.particles.length - 2], spine.particles[spine.particles.length - 2].pos));

spine.constraints.push(new AngleConstraint(spine.particles[24], spine.particles[23], spine.particles[11], 2.5));

spine.constraints.push(new AngleConstraint(spine.particles[24], spine.particles[23], spine.particles[7], 2.5));

spine.constraints.push(new AngleConstraint(spine.particles[24], spine.particles[23], spine.particles[0], 2.5));


/*
for( var i = 0 i <  23 i++ )
{
	spine[i].constraint = new Constraint(spine[i], spine[i+1], 10)
}
spine[23].constraint = new FixedPosition(spine[23], 100+Math.cos(23/24*Math.PI)*20, 23*10+20)
 */

sim = new VerletJS(640, 480, canvas);

sim.friction = 0.4;

sim.highlightColor = "#0f0";

sim.composites.push(spine);

(animate = function() {
  var bottom, threshold, vertebra, _l, _len, _len1, _m, _ref2, _ref3;
  c.clear();
  sim.frame(16);
  sim.draw();
  c.fillStyle = "Green";
  head.happy = true;
  threshold = 15;
  bottom = spine.particles[spine.particles.length - 1];
  _ref2 = spine.particles;
  for (_l = 0, _len = _ref2.length; _l < _len; _l++) {
    vertebra = _ref2[_l];
    if (vertebra.pos.x < bottom.pos.x - threshold || vertebra.pos.x > bottom.pos.x + threshold) {
      head.happy = false;
    }
  }
  _ref3 = spine.particles;
  for (_m = 0, _len1 = _ref3.length; _m < _len1; _m++) {
    vertebra = _ref3[_m];
    vertebra.draw();
  }
  canvas.style.position = "absolute";
  if (going) {
    return requestAnimationFrame(animate);
  }
})();


/*
dragging = null

onMove = (e)->
	dragging?.x = e.offsetX
	dragging?.y = e.offsetY

onDown = (e) ->
	for vertebra in spine
		if( e.offsetX - 4 < vertebra.x < e.offsetX + 4 and
		    e.offsetY - 4 < vertebra.y < e.offsetY + 4 )
				dragging = spine[i]
				break

onUp = (e)->
	dragging = null

window.addEventListener "mousemove", onMove
window.addEventListener "mousedown", onDown
window.addEventListener "mouseup", onUp
 */

step.onclick = function() {
  going = false;
  return animate();
};

go.onclick = function() {
  if (!going) {
    going = true;
    return animate();
  }
};
